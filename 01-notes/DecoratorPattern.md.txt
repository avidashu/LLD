
# ğŸ“˜ Decorator Design Pattern â€” Complete Notes

---

## 1ï¸âƒ£ What is Decorator Pattern?

**Decorator Pattern** allows behavior to be **added dynamically** to an object by **wrapping it**, without modifying the original class.

> It follows the principle: **Open for extension, closed for modification**.

---

## 2ï¸âƒ£ When to Use Decorator Pattern?

Use Decorator Pattern when:

* You need to add **optional or combinable features**
* You want to avoid **class explosion**
* Behavior needs to be added **at runtime**
* Inheritance becomes rigid or unscalable

### Typical use cases:

* Pizza toppings
* Coffee add-ons
* Text formatting (bold, italic, underline)
* Logging / authentication wrappers

---

## 3ï¸âƒ£ Problem Without Decorator Pattern (Bad Design)

### Naive inheritance approach âŒ

```
Margherita
MargheritaWithCheese
MargheritaWithCheeseAndJalapeno
MargheritaWithCheeseMushroomOlives
```

### Problems:

* âŒ Exponential number of classes
* âŒ Not scalable
* âŒ Violates Openâ€“Closed Principle
* âŒ Hard to maintain and test

---

## 4ï¸âƒ£ Core Idea of Decorator Pattern

> Wrap an object inside another object of the **same base type**, and add behavior before or after delegating the call.

Key concepts:

* **IS-A** relationship (inheritance)
* **HAS-A** relationship (composition)

---

## 5ï¸âƒ£ Roles in Decorator Pattern

| Role               | In Pizza Example                           |
| ------------------ | ------------------------------------------ |
| Component          | `BasePizza`                                |
| Concrete Component | `Margherita`, `Farmhouse`, `MushroomPizza` |
| Decorator          | `Toppings`                                 |
| Concrete Decorator | `ExtraCheeseTopping`, `JalapenoTopping`    |
| Client             | `PizzaStore`                               |

---

## 6ï¸âƒ£ UML Mental Model (Very Important)

```
        BasePizza
            â–²
            |
      ----------------
      |              |
 Margherita       Farmhouse
      â–²
      |
   Toppings (Decorator)
      â–²
      |
 -------------------------
 |                       |
ExtraCheeseTopping   JalapenoTopping
```

Each decorator **wraps** a `BasePizza`.

---

## 7ï¸âƒ£ Component (Base Abstraction)

```java
public abstract class BasePizza {
    public abstract double cost();
}
```

### Why abstract class?

* Common behavior
* Decorators can extend it
* Keeps type hierarchy consistent

---

## 8ï¸âƒ£ Decorator Abstract Class

```java
public abstract class Toppings extends BasePizza {

    protected BasePizza basePizza;

    public Toppings(BasePizza basePizza) {
        this.basePizza = basePizza;
    }

    protected abstract double getToppingCost();

    @Override
    public double cost() {
        return basePizza.cost() + getToppingCost();
    }
}
```

### Key points:

* `Toppings IS-A BasePizza`
* `Toppings HAS-A BasePizza`
* Delegates cost calculation
* Core of Decorator Pattern

---

## 9ï¸âƒ£ Concrete Components (Base Pizzas)

```java
public class Margherita extends BasePizza {
    @Override
    public double cost() {
        return 10.0;
    }
}
```

```java
public class Farmhouse extends BasePizza {
    @Override
    public double cost() {
        return 12.0;
    }
}
```

```java
public class MushroomPizza extends BasePizza {
    @Override
    public double cost() {
        return 15.0;
    }
}
```

ğŸ“Œ These are **standalone objects** â€” no decorators involved yet.

---

## 1ï¸âƒ£0ï¸âƒ£ Concrete Decorators (Toppings)

### Extra Cheese

```java
public class ExtraCheeseTopping extends Toppings {

    public ExtraCheeseTopping(BasePizza basePizza) {
        super(basePizza);
    }

    @Override
    protected double getToppingCost() {
        return 15.0;
    }
}
```

### Jalapeno

```java
public class JalapenoTopping extends Toppings {

    public JalapenoTopping(BasePizza basePizza) {
        super(basePizza);
    }

    @Override
    protected double getToppingCost() {
        return 7.0;
    }
}
```

### Why this works:

* Each decorator adds **only its own responsibility**
* No modification to base pizza
* Fully extensible

---

## 1ï¸âƒ£1ï¸âƒ£ Client Code (Usage)

```java
public class PizzaStore {

    public static void main(String[] args) {

        BasePizza margherita = new Margherita();
        System.out.println("Margherita Pizza Cost: " + margherita.cost());

        BasePizza farmhouse = new Farmhouse();
        System.out.println("Farmhouse Pizza Cost: " + farmhouse.cost());

        BasePizza customPizza =
                new ExtraCheeseTopping(
                    new JalapenoTopping(
                        new Margherita()
                    )
                );

        System.out.println(
            "Margherita with Extra Cheese and Jalapeno Toppings Cost: "
            + customPizza.cost()
        );
    }
}
```

---

## 1ï¸âƒ£2ï¸âƒ£ Runtime Flow (Must Explain in Interview)

For:

```java
new ExtraCheeseTopping(
    new JalapenoTopping(
        new Margherita()
    )
).cost();
```

Execution order:

1. `Margherita.cost()` â†’ 10
2. `JalapenoTopping.getToppingCost()` â†’ +7
3. `ExtraCheeseTopping.getToppingCost()` â†’ +15

âœ… Total = **32**

---

## 1ï¸âƒ£3ï¸âƒ£ Why Decorator is Better Than Inheritance

| Inheritance     | Decorator      |
| --------------- | -------------- |
| Compile-time    | Runtime        |
| Rigid           | Flexible       |
| Class explosion | Composable     |
| Hard to extend  | Easy to extend |

---

## 1ï¸âƒ£4ï¸âƒ£ SOLID Principles Used

| Principle                    | How                                 |
| ---------------------------- | ----------------------------------- |
| SRP                          | Each class has one responsibility   |
| OCP                          | Add toppings without modifying code |
| DIP                          | Client depends on `BasePizza`       |
| Composition over Inheritance | Core design choice                  |

---

## 1ï¸âƒ£5ï¸âƒ£ Advantages

âœ… Avoids class explosion
âœ… Dynamic behavior addition
âœ… Easy extension
âœ… Clean & testable design

---

## 1ï¸âƒ£6ï¸âƒ£ Disadvantages

âŒ Many small classes
âŒ Can be confusing without documentation
âŒ Debugging nested decorators can be tricky

---

## 1ï¸âƒ£7ï¸âƒ£ Decorator vs Strategy (Quick Interview Note)

* **Decorator** â†’ Adds responsibilities
* **Strategy** â†’ Changes behavior

Decorator wraps, Strategy replaces.

---

## 1ï¸âƒ£8ï¸âƒ£ One-Line Interview Definition (Memorize)

> â€œDecorator Pattern allows responsibilities to be added dynamically to objects by wrapping them, without modifying their existing code.â€

---