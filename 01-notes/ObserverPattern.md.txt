

# ğŸ“˜ Observer Design Pattern â€” Complete Notes

---

## 1ï¸âƒ£ What is Observer Pattern?

**Observer Pattern** defines a **one-to-many dependency** between objects such that when **one object (Subject/Observable)** changes its state, **all its dependents (Observers)** are **notified automatically**.

ğŸ“Œ The Subject does **not** know *how* observers react â€” it only notifies them.

---

## 2ï¸âƒ£ When to Use Observer Pattern?

Use Observer Pattern when:

* Multiple objects need to **react to state changes** of another object
* You want to avoid **polling**
* You want to follow **Openâ€“Closed Principle**
* You want **loose coupling** between notifier and receivers

### Real-world examples:

* Stock availability notifications
* Event listeners in UI frameworks
* News subscriptions
* Spring Application Events

---

## 3ï¸âƒ£ Problem Without Observer Pattern (Bad Design)

### Naive implementation:

```java
class StockService {
    int stock;

    void setStock(int count) {
        stock = count;
        if (stock > 0) {
            sendEmail();
            sendSms();
        }
    }
}
```

### âŒ Problems:

* Tight coupling
* Violates Openâ€“Closed Principle
* Hard to add new notification types
* Difficult to test
* Business logic mixed with notification logic

---

## 4ï¸âƒ£ Observer Pattern â€” Core Roles

| Role                     | Responsibility                  |
| ------------------------ | ------------------------------- |
| **Observable / Subject** | Holds state, notifies observers |
| **Observer**             | Reacts to state changes         |
| **Concrete Observable**  | Implements subject logic        |
| **Concrete Observer**    | Implements notification logic   |
| **Client**               | Wires everything together       |

---

## 5ï¸âƒ£ Observer Pattern Structure (High Level)

```
Observable  --->  Observer
   |                |
   | notify()       | update()
   |                |
ConcreteObservable  ConcreteObserver(s)
```

---

## 6ï¸âƒ£ Observer Pattern Interfaces (Your Implementation)

### Observer Interface

```java
public interface NotificationObserver {
    void update();
}
```

ğŸ“Œ Acts as a callback
ğŸ“Œ Observable depends only on this interface

---

### Observable Interface

```java
public interface StockNotificationObservable {

    void add(NotificationObserver observer);
    void remove(NotificationObserver observer);
    void notifySubscribers();

    void setStockCount(int newStock);
    int getStockCount();
}
```

ğŸ“Œ Allows dynamic subscribe/unsubscribe
ğŸ“Œ Exposes state management methods

---

## 7ï¸âƒ£ Concrete Observable

```java
public class IphoneStockObservableImpl
        implements StockNotificationObservable {

    private List<NotificationObserver> observers = new ArrayList<>();
    private int stockCount = 0;

    @Override
    public void add(NotificationObserver observer) {
        observers.add(observer);
    }

    @Override
    public void remove(NotificationObserver observer) {
        observers.remove(observer);
    }

    @Override
    public void notifySubscribers() {
        for (NotificationObserver observer : observers) {
            observer.update();
        }
    }

    @Override
    public void setStockCount(int newStock) {
        if (stockCount == 0 && newStock > 0) {
            notifySubscribers();
        }
        stockCount = newStock;
    }

    @Override
    public int getStockCount() {
        return stockCount;
    }
}
```

### ğŸ”‘ Key Insights:

* Maintains list of observers
* Does **not** know concrete observer types
* Notifies only on meaningful state transition

---

## 8ï¸âƒ£ Concrete Observers

### Email Observer

```java
public class EmailNotificationObserverImpl
        implements NotificationObserver {

    private String emailId;
    private StockNotificationObservable observable;

    public EmailNotificationObserverImpl(
            String emailId,
            StockNotificationObservable observable) {
        this.emailId = emailId;
        this.observable = observable;
    }

    @Override
    public void update() {
        System.out.println(
            "Email sent to " + emailId +
            ": Product is back in stock!"
        );
    }
}
```

---

### Mobile Observer

```java
public class MobileNotificationObserverImpl
        implements NotificationObserver {

    private String phoneNumber;
    private StockNotificationObservable observable;

    public MobileNotificationObserverImpl(
            String phoneNumber,
            StockNotificationObservable observable) {
        this.phoneNumber = phoneNumber;
        this.observable = observable;
    }

    @Override
    public void update() {
        System.out.println(
            "SMS sent to " + phoneNumber +
            ": Product is back in stock!"
        );
    }
}
```

---

## 9ï¸âƒ£ Client Code

```java
public class EcommerceStore {

    public static void main(String[] args) {

        StockNotificationObservable iphoneStock =
                new IphoneStockObservableImpl();

        NotificationObserver emailObserver =
                new EmailNotificationObserverImpl(
                        "user@gmail.com", iphoneStock);

        NotificationObserver smsObserver =
                new MobileNotificationObserverImpl(
                        "9876543210", iphoneStock);

        iphoneStock.add(emailObserver);
        iphoneStock.add(smsObserver);

        iphoneStock.setStockCount(20);
    }
}
```

---

## ğŸ” Runtime Flow (VERY IMPORTANT)

1. Client creates Observable
2. Client creates Observers
3. Observers subscribe using `add()`
4. Stock changes from `0 â†’ >0`
5. Observable calls `notifySubscribers()`
6. Each observerâ€™s `update()` executes

---

## ğŸ” Constructor Injection (Why Used)

Observers receive observable via constructor:

* Ensures dependency is available
* Improves testability
* Avoids setters / mutable state
* Follows Dependency Inversion Principle

---

## 10ï¸âƒ£ Design Principles Used

| Principle      | How                                    |
| -------------- | -------------------------------------- |
| SRP            | Stock logic â‰  notification logic       |
| OCP            | New observer without modifying subject |
| DIP            | Depend on interfaces                   |
| Loose Coupling | Subject unaware of concrete observers  |

---

## 11ï¸âƒ£ Advantages

âœ… Loose coupling
âœ… Easy to extend
âœ… Runtime flexibility
âœ… Clean separation of concerns

---

## 12ï¸âƒ£ Disadvantages

âŒ Too many notifications possible
âŒ Harder to debug runtime flow
âŒ Memory leaks if observers not removed

---

## 13ï¸âƒ£ Observer vs Pub-Sub (Quick Recap)

| Observer     | Pub-Sub               |
| ------------ | --------------------- |
| In-process   | Distributed           |
| Direct calls | Broker-based          |
| Synchronous  | Asynchronous          |
| OO pattern   | Architectural pattern |

---

## 14ï¸âƒ£ Common Interview Mistakes

âŒ Using `if-else` instead of observers
âŒ Subject creating observers
âŒ No interfaces
âŒ No unsubscribe support

---

## 15ï¸âƒ£ One-Line Interview Definition (Memorize)

> â€œObserver Pattern defines a one-to-many dependency where observers are notified automatically when the subjectâ€™s state changes, while keeping them loosely coupled.â€

---

